{% extends 'base.html' %}
{% load static %}

{% block title %}{{ call.get_call_type_display }} Call - ConnectFlow{% endblock %}

{% block extra_css %}
<!--
VIDEO CALL FEATURES IMPLEMENTED:
✅ Audio/Video Calling (WebRTC)
✅ Mute/Unmute Audio
✅ Start/Stop Video
✅ Screen Sharing (separate tile, doesn't replace camera)
✅ Multiple Participants Support
✅ Real-time Chat Sidebar
✅ Polls Creation and Voting
✅ Call Duration Timer
✅ Participant Counter
✅ Local Video Preview (bottom-right)
✅ Permission Error Handling (detailed messages + retry)
✅ Auto-hide Main Sidebar (full-screen experience)
✅ End Call for Everyone
✅ WebSocket Signaling
✅ Responsive Video Grid
✅ Dark Mode UI
-->
<style>
    body { overflow: hidden; }
    .call-container { position: fixed; inset: 0; background: #1a1a2e; display: flex; z-index: 50; }
    .video-section { flex: 1; display: flex; flex-direction: column; position: relative; }
    .video-grid { flex: 1; display: grid; gap: 0.5rem; padding: 1rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); overflow-y: auto; padding-bottom: 100px; }
    .video-tile { position: relative; background: #16213e; border-radius: 1rem; overflow: hidden; min-height: 200px; }
    .video-tile video { width: 100%; height: 100%; object-fit: cover; }
    .local-video { position: fixed; bottom: 110px; right: 1rem; width: 200px; height: 150px; border-radius: 0.5rem; overflow: hidden; border: 2px solid #4f46e5; z-index: 80; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
    .call-controls { position: fixed; bottom: 0; left: 0; right: 350px; padding: 1rem; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); display: flex; justify-content: center; gap: 1rem; z-index: 100; transition: right 0.3s; }
    .call-controls.chat-open { right: 350px; }
    .call-controls.chat-closed { right: 0; }
    .control-btn { width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; border: none; }
    .control-btn:hover { transform: scale(1.1); }
    .control-btn.active { background: #4f46e5; }
    .control-btn.inactive { background: #374151; }
    .control-btn.end-call { background: #ef4444; }
    .participant-name { position: absolute; bottom: 0.5rem; left: 0.5rem; background: rgba(0,0,0,0.7); color: white; padding: 0.25rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 600; z-index: 1; }
    
    /* Hide main sidebar during call */
    #sidebar { display: none !important; }
    #mobile-sidebar { display: none !important; }
    
    /* Chat Sidebar */
    .chat-sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 350px; background: #0f172a; border-left: 1px solid #334155; display: flex; flex-direction: column; transform: translateX(100%); transition: transform 0.3s; z-index: 90; }
    .chat-sidebar.open { transform: translateX(0); }
    .chat-header { padding: 1rem; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; z-index: 91; }
    .chat-messages { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; padding-bottom: 1rem; }
    .chat-message { background: #1e293b; padding: 0.75rem; border-radius: 0.5rem; }
    .chat-message .sender { font-weight: 600; color: #818cf8; font-size: 0.875rem; margin-bottom: 0.25rem; }
    .chat-message .text { color: #e2e8f0; font-size: 0.875rem; }
    .chat-input-area { padding: 1rem; border-top: 1px solid #334155; }
    .poll-option { background: #1e293b; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; transition: all 0.2s; }
    .poll-option:hover { background: #334155; }
    .poll-option.voted { background: #4f46e5; }
    .poll-result { height: 4px; background: #4f46e5; border-radius: 2px; margin-top: 0.5rem; }
    
    /* Poll Modal */
    #create-poll-modal { z-index: 300 !important; }
    #create-poll-modal .bg-slate-800 { position: relative; z-index: 301; }

</style>
<script>
// Hide sidebar immediately when call page loads
document.addEventListener('DOMContentLoaded', function() {
    const sidebar = document.getElementById('sidebar');
    const mobileSidebar = document.getElementById('mobile-sidebar');
    const mainContent = document.querySelector('main');
    
    if (sidebar) sidebar.style.display = 'none';
    if (mobileSidebar) mobileSidebar.style.display = 'none';
    if (mainContent) mainContent.style.marginLeft = '0';
});
</script>
{% endblock %}

{% block content %}
<div class="call-container">
    <div class="video-section">
        <!-- Header -->
        <div class="flex items-center justify-between p-4 bg-black bg-opacity-50">
            <div>
                <h1 class="text-white text-xl font-bold">{{ call.get_call_type_display }} Call</h1>
                <p class="text-gray-400 text-sm" id="call-duration">00:00</p>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-white text-sm" id="participant-count">{{ participants.count }} participant{{ participants.count|pluralize }}</span>
            </div>
        </div>

        <!-- Video Grid -->
        <div class="video-grid" id="video-grid">
            <!-- Remote videos will be added here -->
        </div>
    </div>
    
    <!-- Local Video Preview (Fixed Position) -->
    <div class="local-video" id="local-video-container">
        <video id="local-video" autoplay muted playsinline></video>
        <div class="participant-name">You</div>
    </div>

    <!-- Call Controls (Fixed Position) -->
    <div class="call-controls">
        <button id="toggle-audio" class="control-btn active" title="Mute/Unmute">
            <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24" id="mic-on-icon">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
            <svg class="w-6 h-6 text-white hidden" fill="currentColor" viewBox="0 0 24 24" id="mic-off-icon">
                <path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z"/>
            </svg>
        </button>

        {% if call.call_type == 'VIDEO' %}
        <button id="toggle-video" class="control-btn active" title="Start/Stop Video">
            <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24" id="video-on-icon">
                <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
            </svg>
            <svg class="w-6 h-6 text-white hidden" fill="currentColor" viewBox="0 0 24 24" id="video-off-icon">
                <path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z"/>
            </svg>
        </button>
        {% endif %}

        <button id="share-screen" class="control-btn inactive" title="Share Screen">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
        </button>
        
        <button id="toggle-chat" class="control-btn inactive" title="Toggle Chat">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
            </svg>
        </button>

        <button id="end-call" class="control-btn end-call" title="End Call">
            <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.68-1.36-2.66-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/>
            </svg>
        </button>
    </div>
    
    <!-- Chat Sidebar -->
    <div class="chat-sidebar" id="chat-sidebar">
        <div class="chat-header">
            <div>
                <h3 class="text-white font-bold text-lg">Chat</h3>
                <div class="flex gap-2 mt-2">
                    <button id="chat-tab" class="text-indigo-400 text-sm font-semibold border-b-2 border-indigo-400 pb-1">Messages</button>
                    <button id="poll-tab" class="text-gray-400 text-sm font-semibold pb-1">Polls</button>
                </div>
            </div>
            <button onclick="toggleChat()" class="text-gray-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <!-- Chat Messages -->
        <div id="chat-tab-content" class="chat-messages">
            <!-- Messages will be added here -->
        </div>
        
        <!-- Poll Content -->
        <div id="poll-tab-content" class="chat-messages" style="display: none;">
            <button onclick="showCreatePoll()" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 mb-4">
                Create Poll
            </button>
            <div id="polls-list">
                <!-- Polls will be added here -->
            </div>
        </div>
        
        <!-- Chat Input -->
        <div class="chat-input-area">
            <div class="flex gap-2">
                <input type="text" id="chat-input" placeholder="Type a message..." class="flex-1 bg-slate-800 text-white px-4 py-2 rounded-lg border border-slate-700 focus:outline-none focus:border-indigo-500">
                <button onclick="sendChatMessage()" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Create Poll Modal -->
<div id="create-poll-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-slate-800 rounded-lg p-6 w-96">
        <h3 class="text-white text-xl font-bold mb-4">Create Poll</h3>
        <input type="text" id="poll-question" placeholder="Poll question" class="w-full bg-slate-700 text-white px-4 py-2 rounded-lg mb-3 border border-slate-600 focus:outline-none focus:border-indigo-500">
        <div id="poll-options-container">
            <input type="text" class="poll-option-input w-full bg-slate-700 text-white px-4 py-2 rounded-lg mb-2 border border-slate-600" placeholder="Option 1">
            <input type="text" class="poll-option-input w-full bg-slate-700 text-white px-4 py-2 rounded-lg mb-2 border border-slate-600" placeholder="Option 2">
        </div>
        <button onclick="addPollOption()" class="text-indigo-400 text-sm mb-4">+ Add Option</button>
        <div class="flex gap-2">
            <button onclick="createPoll()" class="flex-1 bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700">Create</button>
            <button onclick="closePollModal()" class="flex-1 bg-slate-700 text-white py-2 rounded-lg hover:bg-slate-600">Cancel</button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const callId = '{{ call.id }}';
const userId = '{{ user.id }}';
const userName = '{{ user.get_full_name|default:user.username }}';
const isInitiator = {% if is_initiator %}true{% else %}false{% endif %};
const callType = '{{ call.call_type }}';
const iceServers = {{ ice_servers|safe }};

let localStream = null;
let peerConnections = {};
let callSocket = null;
let isAudioEnabled = true;
let isVideoEnabled = true;
let isScreenSharing = false;

// Initialize
document.addEventListener('DOMContentLoaded', async () => {
    await initLocalStream();
    connectWebSocket();
    startCallTimer();
    setupEventListeners();
});

async function initLocalStream() {
    try {
        const constraints = {
            audio: true,
            video: callType === 'VIDEO' ? { width: 1280, height: 720 } : false
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('local-video').srcObject = localStream;
        
        console.log('Local stream initialized');
    } catch (err) {
        console.error('Failed to get local stream:', err);
        
        let errorMessage = 'Failed to access camera/microphone. ';
        
        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            errorMessage += 'Permission denied. Please allow access to your camera and microphone in browser settings and refresh the page.';
        } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            errorMessage += 'No camera or microphone found. Please connect a device and try again.';
        } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
            errorMessage += 'Camera/microphone is already in use by another application. Please close other apps and try again.';
        } else if (err.name === 'OverconstrainedError') {
            errorMessage += 'Camera/microphone does not support the requested settings. Trying with basic settings...';
            // Try again with basic constraints
            try {
                const basicConstraints = {
                    audio: true,
                    video: callType === 'VIDEO' ? true : false
                };
                localStream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                document.getElementById('local-video').srcObject = localStream;
                console.log('Local stream initialized with basic settings');
                return;
            } catch (retryErr) {
                errorMessage = 'Failed to access camera/microphone even with basic settings. ' + retryErr.message;
            }
        } else if (err.name === 'TypeError') {
            errorMessage += 'Browser does not support camera/microphone access. Please use a modern browser like Chrome, Firefox, or Edge.';
        } else {
            errorMessage += err.message || 'Unknown error occurred.';
        }
        
        // Show error modal instead of alert
        showPermissionError(errorMessage, err.name);
    }
}

function showPermissionError(message, errorType) {
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-slate-800 rounded-lg p-8 max-w-md mx-4">
            <div class="flex items-center justify-center w-16 h-16 mx-auto mb-4 bg-red-100 rounded-full">
                <svg class="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
            </div>
            <h3 class="text-xl font-bold text-white text-center mb-4">Permission Required</h3>
            <p class="text-gray-300 text-center mb-6">${message}</p>
            <div class="space-y-3">
                ${errorType === 'NotAllowedError' || errorType === 'PermissionDeniedError' ? `
                    <div class="bg-indigo-900 bg-opacity-50 p-4 rounded-lg">
                        <p class="text-sm text-gray-300 mb-2"><strong>How to allow permissions:</strong></p>
                        <ul class="text-sm text-gray-400 space-y-1 list-disc list-inside">
                            <li>Click the camera/lock icon in your browser's address bar</li>
                            <li>Select "Allow" for camera and microphone</li>
                            <li>Refresh this page</li>
                        </ul>
                    </div>
                ` : ''}
                <div class="flex gap-3">
                    <button onclick="window.location.reload()" class="flex-1 bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 font-semibold">
                        Retry
                    </button>
                    <button onclick="window.location.href='/channels/'" class="flex-1 bg-gray-700 text-white py-3 rounded-lg hover:bg-gray-600 font-semibold">
                        Exit Call
                    </button>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function connectWebSocket() {
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${wsScheme}://${window.location.host}/ws/call/${callId}/`;
    
    callSocket = new WebSocket(wsUrl);
    
    callSocket.onopen = () => {
        console.log('WebSocket connected');
        // Announce presence
        callSocket.send(JSON.stringify({
            type: 'join',
            user_id: userId,
            user_name: userName
        }));
    };
    
    callSocket.onmessage = async (e) => {
        const data = JSON.parse(e.data);
        console.log('WebSocket message:', data);
        
        switch(data.type) {
            case 'user_joined':
                await handleUserJoined(data);
                break;
            case 'user_left':
                handleUserLeft(data);
                break;
            case 'webrtc_offer':
                await handleOffer(data);
                break;
            case 'webrtc_answer':
                await handleAnswer(data);
                break;
            case 'ice_candidate':
                await handleIceCandidate(data);
                break;
            case 'call_ended':
                handleCallEnded();
                break;
        }
    };
    
    callSocket.onclose = () => {
        console.log('WebSocket disconnected');
    };
}

async function handleUserJoined(data) {
    const peerId = data.user_id;
    if (peerId === userId) return;
    
    console.log('User joined:', data.user_name);
    
    // Create peer connection
    const pc = createPeerConnection(peerId, data.user_name);
    
    // Create and send offer
    if (data.should_create_offer) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        callSocket.send(JSON.stringify({
            type: 'webrtc_offer',
            target_user_id: peerId,
            offer: offer
        }));
    }
    
    updateParticipantCount();
}

function handleUserLeft(data) {
    const peerId = data.user_id;
    console.log('User left:', data.user_name);
    
    if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
    }
    
    const videoElement = document.getElementById(`video-${peerId}`);
    if (videoElement) {
        videoElement.parentElement.remove();
    }
    
    updateParticipantCount();
}

async function handleOffer(data) {
    const peerId = data.sender_id;
    const pc = createPeerConnection(peerId, data.sender_name);
    
    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    
    callSocket.send(JSON.stringify({
        type: 'webrtc_answer',
        target_user_id: peerId,
        answer: answer
    }));
}

async function handleAnswer(data) {
    const peerId = data.sender_id;
    const pc = peerConnections[peerId];
    
    if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
    }
}

async function handleIceCandidate(data) {
    const peerId = data.sender_id;
    const pc = peerConnections[peerId];
    
    if (pc && data.candidate) {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
    }
}

function createPeerConnection(peerId, peerName) {
    const pc = new RTCPeerConnection({ iceServers: iceServers });
    peerConnections[peerId] = pc;
    
    // Add local stream tracks
    if (localStream) {
        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        });
    }
    
    // Handle ICE candidates
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            callSocket.send(JSON.stringify({
                type: 'ice_candidate',
                target_user_id: peerId,
                candidate: event.candidate
            }));
        }
    };
    
    // Handle remote stream
    pc.ontrack = (event) => {
        console.log('Remote track received from', peerName);
        addRemoteVideo(peerId, peerName, event.streams[0]);
    };
    
    return pc;
}

function addRemoteVideo(peerId, peerName, stream) {
    let videoTile = document.getElementById(`video-tile-${peerId}`);
    
    if (!videoTile) {
        videoTile = document.createElement('div');
        videoTile.id = `video-tile-${peerId}`;
        videoTile.className = 'video-tile';
        videoTile.innerHTML = `
            <video id="video-${peerId}" autoplay playsinline></video>
            <div class="participant-name">${peerName}</div>
        `;
        document.getElementById('video-grid').appendChild(videoTile);
    }
    
    const video = document.getElementById(`video-${peerId}`);
    video.srcObject = stream;
}

function setupEventListeners() {
    document.getElementById('toggle-audio').addEventListener('click', toggleAudio);
    if (callType === 'VIDEO') {
        document.getElementById('toggle-video').addEventListener('click', toggleVideo);
    }
    document.getElementById('share-screen').addEventListener('click', toggleScreenShare);
    document.getElementById('end-call').addEventListener('click', endCall);
}

function toggleAudio() {
    isAudioEnabled = !isAudioEnabled;
    localStream.getAudioTracks().forEach(track => track.enabled = isAudioEnabled);
    
    const btn = document.getElementById('toggle-audio');
    const micOn = document.getElementById('mic-on-icon');
    const micOff = document.getElementById('mic-off-icon');
    
    btn.classList.toggle('active', isAudioEnabled);
    btn.classList.toggle('inactive', !isAudioEnabled);
    micOn.classList.toggle('hidden', !isAudioEnabled);
    micOff.classList.toggle('hidden', isAudioEnabled);
}

function toggleVideo() {
    isVideoEnabled = !isVideoEnabled;
    localStream.getVideoTracks().forEach(track => track.enabled = isVideoEnabled);
    
    const btn = document.getElementById('toggle-video');
    const vidOn = document.getElementById('video-on-icon');
    const vidOff = document.getElementById('video-off-icon');
    
    btn.classList.toggle('active', isVideoEnabled);
    btn.classList.toggle('inactive', !isVideoEnabled);
    vidOn.classList.toggle('hidden', !isVideoEnabled);
    vidOff.classList.toggle('hidden', isVideoEnabled);
}

async function toggleScreenShare() {
    if (!isScreenSharing) {
        try {
            const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            const screenTrack = screenStream.getVideoTracks()[0];
            
            // Add screen share track to peer connections (don't replace camera)
            Object.values(peerConnections).forEach(pc => {
                pc.addTrack(screenTrack, screenStream);
            });
            
            // Add screen share to video grid (keep camera in local preview)
            const screenTile = document.createElement('div');
            screenTile.id = 'screen-share-tile';
            screenTile.className = 'video-tile';
            screenTile.innerHTML = `
                <video id="screen-share-video" autoplay playsinline></video>
                <div class="participant-name">Your Screen</div>
            `;
            document.getElementById('video-grid').appendChild(screenTile);
            document.getElementById('screen-share-video').srcObject = screenStream;
            
            screenTrack.onended = () => {
                toggleScreenShare();
            };
            
            isScreenSharing = true;
            document.getElementById('share-screen').classList.add('active');
            document.getElementById('share-screen').classList.remove('inactive');
        } catch (err) {
            console.error('Screen share error:', err);
        }
    } else {
        // Stop screen share
        const screenTile = document.getElementById('screen-share-tile');
        if (screenTile) {
            const video = document.getElementById('screen-share-video');
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            screenTile.remove();
        }
        
        // Remove screen track from peer connections
        Object.values(peerConnections).forEach(pc => {
            const screenSender = pc.getSenders().find(s => 
                s.track?.kind === 'video' && s.track?.label.includes('screen')
            );
            if (screenSender) {
                pc.removeTrack(screenSender);
            }
        });
        
        isScreenSharing = false;
        document.getElementById('share-screen').classList.remove('active');
        document.getElementById('share-screen').classList.add('inactive');
    }
}

async function endCall() {
    if (confirm('End call for everyone?')) {
        const response = await fetch(`/calls/${callId}/end/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        });
        
        if (response.ok) {
            cleanup();
            window.location.href = '/channels/';
        }
    }
}

function handleCallEnded() {
    alert('Call has ended');
    cleanup();
    window.location.href = '/channels/';
}

function cleanup() {
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    
    Object.values(peerConnections).forEach(pc => pc.close());
    
    if (callSocket) {
        callSocket.close();
    }
}

function startCallTimer() {
    let seconds = 0;
    setInterval(() => {
        seconds++;
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        document.getElementById('call-duration').textContent = 
            `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }, 1000);
}

function updateParticipantCount() {
    const count = Object.keys(peerConnections).length + 1;
    document.getElementById('participant-count').textContent = 
        `${count} participant${count !== 1 ? 's' : ''}`;
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Cleanup on page unload
window.addEventListener('beforeunload', cleanup);

// Chat functionality
function toggleChat() {
    const sidebar = document.getElementById('chat-sidebar');
    const button = document.getElementById('toggle-chat');
    const controls = document.querySelector('.call-controls');
    
    sidebar.classList.toggle('open');
    button.classList.toggle('active');
    button.classList.toggle('inactive');
    
    // Adjust controls position when chat opens/closes
    if (sidebar.classList.contains('open')) {
        controls.classList.add('chat-open');
        controls.classList.remove('chat-closed');
    } else {
        controls.classList.add('chat-closed');
        controls.classList.remove('chat-open');
    }
}

function sendChatMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    if (!message) return;
    
    // Send via WebSocket
    if (callSocket && callSocket.readyState === WebSocket.OPEN) {
        callSocket.send(JSON.stringify({
            type: 'chat_message',
            message: message,
            sender_name: userName
        }));
    }
    
    // Add to UI
    addChatMessage(userName, message, true);
    input.value = '';
}

function addChatMessage(sender, message, isSelf = false) {
    const container = document.getElementById('chat-tab-content');
    const div = document.createElement('div');
    div.className = 'chat-message';
    div.innerHTML = `
        <div class="sender" style="color: ${isSelf ? '#818cf8' : '#f472b6'}">${sender}</div>
        <div class="text">${escapeHtml(message)}</div>
    `;
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
}

// Tab switching
document.getElementById('chat-tab').addEventListener('click', function() {
    document.getElementById('chat-tab-content').style.display = 'flex';
    document.getElementById('poll-tab-content').style.display = 'none';
    this.classList.add('text-indigo-400', 'border-b-2', 'border-indigo-400');
    this.classList.remove('text-gray-400');
    document.getElementById('poll-tab').classList.remove('text-indigo-400', 'border-b-2', 'border-indigo-400');
    document.getElementById('poll-tab').classList.add('text-gray-400');
});

document.getElementById('poll-tab').addEventListener('click', function() {
    document.getElementById('chat-tab-content').style.display = 'none';
    document.getElementById('poll-tab-content').style.display = 'flex';
    this.classList.add('text-indigo-400', 'border-b-2', 'border-indigo-400');
    this.classList.remove('text-gray-400');
    document.getElementById('chat-tab').classList.remove('text-indigo-400', 'border-b-2', 'border-indigo-400');
    document.getElementById('chat-tab').classList.add('text-gray-400');
});

// Poll functionality
let polls = [];
let pollIdCounter = 0;

function showCreatePoll() {
    document.getElementById('create-poll-modal').classList.remove('hidden');
}

function closePollModal() {
    document.getElementById('create-poll-modal').classList.add('hidden');
    document.getElementById('poll-question').value = '';
    document.querySelectorAll('.poll-option-input').forEach((input, i) => {
        if (i < 2) input.value = '';
        else input.remove();
    });
}

function addPollOption() {
    const container = document.getElementById('poll-options-container');
    const optionNum = container.children.length + 1;
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'poll-option-input w-full bg-slate-700 text-white px-4 py-2 rounded-lg mb-2 border border-slate-600';
    input.placeholder = `Option ${optionNum}`;
    container.appendChild(input);
}

function createPoll() {
    const question = document.getElementById('poll-question').value.trim();
    const optionInputs = document.querySelectorAll('.poll-option-input');
    const options = Array.from(optionInputs).map(input => input.value.trim()).filter(val => val);
    
    if (!question || options.length < 2) {
        alert('Please enter a question and at least 2 options');
        return;
    }
    
    const poll = {
        id: pollIdCounter++,
        question: question,
        options: options.map(opt => ({ text: opt, votes: 0 })),
        voted: false,
        creator: userName
    };
    
    polls.push(poll);
    
    // Broadcast poll
    if (callSocket && callSocket.readyState === WebSocket.OPEN) {
        callSocket.send(JSON.stringify({
            type: 'poll_created',
            poll: poll
        }));
    }
    
    renderPolls();
    closePollModal();
}

function votePoll(pollId, optionIndex) {
    const poll = polls.find(p => p.id === pollId);
    if (!poll || poll.voted) return;
    
    poll.options[optionIndex].votes++;
    poll.voted = true;
    
    // Broadcast vote
    if (callSocket && callSocket.readyState === WebSocket.OPEN) {
        callSocket.send(JSON.stringify({
            type: 'poll_vote',
            poll_id: pollId,
            option_index: optionIndex
        }));
    }
    
    renderPolls();
}

function renderPolls() {
    const container = document.getElementById('polls-list');
    container.innerHTML = '';
    
    polls.forEach(poll => {
        const totalVotes = poll.options.reduce((sum, opt) => sum + opt.votes, 0);
        const div = document.createElement('div');
        div.className = 'bg-slate-900 p-4 rounded-lg mb-4';
        
        let optionsHTML = poll.options.map((opt, i) => {
            const percentage = totalVotes > 0 ? (opt.votes / totalVotes) * 100 : 0;
            return `
                <div class="poll-option ${poll.voted ? 'cursor-not-allowed' : ''}" data-poll-id="${poll.id}" data-option-index="${i}" ${poll.voted ? '' : 'style="cursor: pointer;"'}>
                    <div class="flex justify-between items-center">
                        <span class="text-white">${escapeHtml(opt.text)}</span>
                        ${poll.voted ? `<span class="text-gray-400 text-sm">${opt.votes} (${percentage.toFixed(0)}%)</span>` : ''}
                    </div>
                    ${poll.voted ? `<div class="poll-result" style="width: ${percentage}%"></div>` : ''}
                </div>
            `;
        }).join('');
        
        div.innerHTML = `
            <div class="text-indigo-400 font-semibold mb-3">${escapeHtml(poll.question)}</div>
            <div class="text-xs text-gray-500 mb-3">Created by ${escapeHtml(poll.creator)}</div>
            ${optionsHTML}
        `;
        
        container.appendChild(div);
    });
    
    // Add event delegation for poll voting
    container.querySelectorAll('.poll-option').forEach(option => {
        if (!option.classList.contains('cursor-not-allowed')) {
            option.addEventListener('click', function() {
                const pollId = parseInt(this.getAttribute('data-poll-id'));
                const optionIndex = parseInt(this.getAttribute('data-option-index'));
                votePoll(pollId, optionIndex);
            });
        }
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle chat/poll messages via WebSocket
const originalOnMessage = callSocket ? callSocket.onmessage : null;
if (callSocket) {
    callSocket.addEventListener('message', (e) => {
        const data = JSON.parse(e.data);
        
        if (data.type === 'chat_message') {
            addChatMessage(data.sender_name, data.message, data.sender_id === userId);
        } else if (data.type === 'poll_created') {
            polls.push(data.poll);
            renderPolls();
        } else if (data.type === 'poll_vote') {
            const poll = polls.find(p => p.id === data.poll_id);
            if (poll) {
                poll.options[data.option_index].votes++;
                renderPolls();
            }
        }
    });
}

// Enter to send message
document.getElementById('chat-input').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendChatMessage();
    }
});

// Toggle chat button
document.getElementById('toggle-chat').addEventListener('click', toggleChat);
</script>
{% endblock %}
